<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>spring回顾 | wq-9</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IOC的使用[1]责任链   我们使用mvc进行开发的时候，数据在各层之间进行传递，数据在业务上构成一个链条， 这个链条称之为责任链。 [2]基于责任链开发的缺点基于责任链开发模式，我们发现代码层和层之间相互调用，造成了层和层的耦合性太高了  我们写代码的时候讲究的原则–低耦合  高内聚 [3] 解决的方案Spring  IOC : 控制反转[4]代码实现  A、导包 B、创建src下的java类">
<meta property="og:type" content="article">
<meta property="og:title" content="spring回顾">
<meta property="og:url" content="http://yoursite.com/2019/09/30/spring回顾/index.html">
<meta property="og:site_name" content="wq-9">
<meta property="og:description" content="IOC的使用[1]责任链   我们使用mvc进行开发的时候，数据在各层之间进行传递，数据在业务上构成一个链条， 这个链条称之为责任链。 [2]基于责任链开发的缺点基于责任链开发模式，我们发现代码层和层之间相互调用，造成了层和层的耦合性太高了  我们写代码的时候讲究的原则–低耦合  高内聚 [3] 解决的方案Spring  IOC : 控制反转[4]代码实现  A、导包 B、创建src下的java类">
<meta property="og:locale" content="default">
<meta property="og:image" content="d:%5Cgit%5Cblogs%5Csource_posts%5Cimages%5C9.png">
<meta property="og:updated_time" content="2019-10-06T14:16:42.990Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring回顾">
<meta name="twitter:description" content="IOC的使用[1]责任链   我们使用mvc进行开发的时候，数据在各层之间进行传递，数据在业务上构成一个链条， 这个链条称之为责任链。 [2]基于责任链开发的缺点基于责任链开发模式，我们发现代码层和层之间相互调用，造成了层和层的耦合性太高了  我们写代码的时候讲究的原则–低耦合  高内聚 [3] 解决的方案Spring  IOC : 控制反转[4]代码实现  A、导包 B、创建src下的java类">
<meta name="twitter:image" content="d:%5Cgit%5Cblogs%5Csource_posts%5Cimages%5C9.png">
  
    <link rel="alternate" href="/atom.xml" title="wq-9" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wq-9</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-spring回顾" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/30/spring回顾/" class="article-date">
  <time datetime="2019-09-30T05:58:02.000Z" itemprop="datePublished">2019-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      spring回顾
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="IOC的使用"><a href="#IOC的使用" class="headerlink" title="IOC的使用"></a>IOC的使用</h1><h2 id="1-责任链"><a href="#1-责任链" class="headerlink" title="[1]责任链"></a>[1]责任链</h2><p>   我们使用mvc进行开发的时候，数据在各层之间进行传递，数据在业务上构成一个链条，</p>
<p>这个链条称之为责任链。</p>
<h2 id="2-基于责任链开发的缺点"><a href="#2-基于责任链开发的缺点" class="headerlink" title="[2]基于责任链开发的缺点"></a>[2]基于责任链开发的缺点</h2><pre><code>基于责任链开发模式，我们发现代码层和层之间相互调用，造成了层和层的耦合性太高了</code></pre><p>  我们写代码的时候讲究的原则–低耦合  高内聚</p>
<h2 id="3-解决的方案"><a href="#3-解决的方案" class="headerlink" title="[3] 解决的方案"></a>[3] 解决的方案</h2><pre><code>Spring  IOC : 控制反转</code></pre><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="[4]代码实现"></a>[4]代码实现</h2><p>  A、导包</p>
<pre><code>B、创建src下的java类</code></pre><p>   C、书写applicationContext.xml文件<br><?xml version="1.0" encoding="UTF-8"?><br><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd"><br>    <!--Student  stu =new Student()--><br>    <bean id="stu" class="com.bjsxt.spring1.Student"></bean><br></beans></p>
<p>  D、解析xml调用对象</p>
<p>public class Test {<br>    public static void main(String[] args) {<br>       // Student  stu =new Student();<br>      //[1]解析xml文件<br>        ApplicationContext  app=new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>      //[2]获得对象<br>        //Student  stu = (Student) app.getBean(“stu”);<br>        Student stu1 = app.getBean(“stu”, Student.class);<br>        stu1.eat();<br>    }<br>}</p>
<p>Spring IOC的好处</p>
<pre><code>实现了各层之间的解耦</code></pre><h2 id="5-IOC-控制反转"><a href="#5-IOC-控制反转" class="headerlink" title="[5]IOC :控制反转"></a>[5]IOC :控制反转</h2><pre><code>控制：就是指的的Spring创建对象的过程

反转：创建对象这个操作本身是程序员自己做的，现在反交给Spring IOC进行创建</code></pre><h1 id="IOC实现的方式"><a href="#IOC实现的方式" class="headerlink" title="IOC实现的方式"></a>IOC实现的方式</h1><p>  A、使用无参构造器</p>
<p>   B、使用有参构造器</p>
<p>   C、使用工厂模式</p>
<h2 id="1-使用无参构造"><a href="#1-使用无参构造" class="headerlink" title="[1]使用无参构造"></a>[1]使用无参构造</h2><p><bean id="stu2" class="com.bjsxt.spring2.Student"></bean></p>
<h2 id="2-使用有参构造"><a href="#2-使用有参构造" class="headerlink" title="[2]使用有参构造"></a>[2]使用有参构造</h2><!--【B】使用有参构造创建对象-->
<pre><code>&lt;!--
   Student  stu3=new Student(18,zs,男);
   注意
     [1]name属性和形参的名称保持一致的
     [2]形参的顺序不用和标签的顺序一致
     [3]我们使用name属性进行调用
        但是除了name属性还有index（从0）
        type ：数据类型
        建议三者都写上即可
--&gt;
&lt;bean id=&quot;stu3&quot; class=&quot;com.bjsxt.spring2.Student&quot;&gt;
    &lt;!--&lt;constructor-arg name=&quot;a&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;zs&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/constructor-arg&gt;--&gt;
    &lt;constructor-arg name=&quot;a&quot; index=&quot;1&quot; type=&quot;int&quot; value=&quot;123&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;b&quot; index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;456&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><h2 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="[3]工厂模式"></a>[3]工厂模式</h2><pre><code>设计模式：设计模式是为了解决某一类问题的产生

工厂模式就是批量生产对象的</code></pre> <!--【3】使用工厂模式创建对象-->
<pre><code>&lt;!-- Factory  factory=new Factory();--&gt;
&lt;bean id=&quot;factory&quot; class=&quot;com.bjsxt.spring3.Factory&quot;&gt;&lt;/bean&gt;
&lt;!-- factory.getInstance(&quot;tea&quot;);--&gt;
&lt;bean id=&quot;be&quot; factory-bean=&quot;factory&quot; factory-method=&quot;getInstance&quot;&gt;
    &lt;constructor-arg name=&quot;param&quot; value=&quot;stu&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;!--Factory.getInstance2(&apos;stu&apos;)--&gt;
&lt;bean id=&quot;be2&quot; class=&quot;com.bjsxt.spring3.Factory&quot; factory-method=&quot;getInstance2&quot;&gt;
    &lt;constructor-arg name=&quot;param&quot; value=&quot;stu&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><h1 id="依赖注入的概念"><a href="#依赖注入的概念" class="headerlink" title="依赖注入的概念"></a>依赖注入的概念</h1><h2 id="1-为什么使用DI（依赖注入）"><a href="#1-为什么使用DI（依赖注入）" class="headerlink" title="[1]为什么使用DI（依赖注入）"></a>[1]为什么使用DI（依赖注入）</h2><p>作用：给创建好的对象中的全局的属性或者对象进行赋值的操作</p>
<h2 id="2-利用DI进行解决"><a href="#2-利用DI进行解决" class="headerlink" title="[2]利用DI进行解决"></a>[2]利用DI进行解决</h2><ol>
<li><h3 id="英文全称-Dependency-Injection"><a href="#英文全称-Dependency-Injection" class="headerlink" title="英文全称(Dependency Injection)"></a>英文全称(Dependency Injection)</h3></li>
<li><h3 id="中文名称-依赖注入"><a href="#中文名称-依赖注入" class="headerlink" title="中文名称:依赖注入"></a>中文名称:依赖注入</h3></li>
</ol>
<p>2.1 依赖:一个类在另一个类中作为全局属性时<br>  2.2 注入:通过外部给自己属性(或其他内容)进行赋值</p>
<ol start="3">
<li><h3 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系:"></a>类与类之间的关系:</h3><p>3.1 继承(官方名称:泛化)<br>3.2 实现<br>3.3 依赖:类和类之间的关系是偶然的,临时的.在代码层面另一个类当作这个类的方法参数或局部变量<br>3.4 关联:类与类之间存在一定联系,可以是单向联系可以是双向联系.例如:学生和老师. (平时理解关联是一种强依赖),体现在代码层面,另一个类是这个类的全局属性.<br>3.5 聚合:类与类之间是可以单独存在的.但是有存在整体和部分的关系.例如:机箱和CPU.体现在代码层面:另一个类是这个类的全局属性.<br>3.6 组合:类与类之间是整体和部分之间的部分,不可分.例如人和心脏.体现在代码层面:另一个类是这个类的全局属性.</p>
</li>
<li><p>7 关系强度:组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
<h2 id="4-DI的意义"><a href="#4-DI的意义" class="headerlink" title="4.DI的意义"></a>4.DI的意义</h2><p> 4.1 解除类与类之间高耦合性，给对象中全局对象赋值的操作</p>
</li>
</ol>
<h2 id="5-为什么称DI和IoC是同一个事情"><a href="#5-为什么称DI和IoC是同一个事情" class="headerlink" title="5.为什么称DI和IoC是同一个事情."></a>5.为什么称DI和IoC是同一个事情.</h2><p>   5.1 Spring帮助创建对象的过程叫做IoC,创建对象时给对象中全局对象赋值叫做DI,所以认为IoC和DI是同一个事情.</p>
<h1 id="DI注入的方式"><a href="#DI注入的方式" class="headerlink" title="DI注入的方式"></a>DI注入的方式</h1><h2 id="A、使用set方法"><a href="#A、使用set方法" class="headerlink" title="A、使用set方法"></a>A、使用set方法</h2>  <!--【A】使用set方法进行DI注入-->
<pre><code>&lt;!--
    name:对象的属性名
    value和ref的使用场景
    value: 如果注入的属性类型是基本数据类型（包含String）使用value
    ref:如果注入的属性类型是对象这个时候使用ref
--&gt;
&lt;bean id=&quot;stu&quot; class=&quot;com.bjsxt.spring4.Student&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;lisi&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;clazz&quot;  ref=&quot;cla&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre><h2 id="B、使用有参构造器"><a href="#B、使用有参构造器" class="headerlink" title="B、使用有参构造器"></a>B、使用有参构造器</h2> <!--【B】有参构造方式进行注入-->
<pre><code>&lt;bean id=&quot;cla&quot; class=&quot;com.bjsxt.spring4.Clazz&quot;&gt;
     &lt;constructor-arg name=&quot;cname&quot; value=&quot;java1班&quot;&gt;&lt;/constructor-arg&gt;
     &lt;constructor-arg name=&quot;clazzno&quot; value=&quot;507&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;bean id=&quot;stu&quot; class=&quot;com.bjsxt.spring4.Student&quot;&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;zs&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;clazz&quot;  ref=&quot;cla&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><h2 id="C、自动注入"><a href="#C、自动注入" class="headerlink" title="C、自动注入"></a>C、自动注入</h2><!--【C】DI中的自动注入-->
<pre><code>&lt;!--
  底层走的是set方法
  byName:这个时候就会在当前的xml中寻找【bean的ID名称】和需要注入实体中的【属性名】一致，进行匹配注入
  byType:这个时候就会在当前的xml中寻找【bean标签的类型】和需要注入实体中的【属性的类型】一致，进行匹配注入
 底层走的是构造器
 constructor：这个时候首先会根据[有参构造器的形参名]名称进行查找，如果名称没有一致的，在根据类型[有参构造器的类型]进行查找
  需要注意：*在指定的类中必须提供合适的有参构造器才可以
--&gt;
&lt;bean id=&quot;stu&quot; class=&quot;com.bjsxt.spring4.Student&quot; autowire=&quot;constructor&quot;&gt;&lt;/bean&gt;</code></pre><h1 id="DI其他类型值的注入"><a href="#DI其他类型值的注入" class="headerlink" title="DI其他类型值的注入"></a>DI其他类型值的注入</h1><h2 id="A、基本类型（String）"><a href="#A、基本类型（String）" class="headerlink" title="A、基本类型（String）"></a>A、基本类型（String）</h2><h2 id="B、对象类型"><a href="#B、对象类型" class="headerlink" title="B、对象类型"></a>B、对象类型</h2><h2 id="C、数组"><a href="#C、数组" class="headerlink" title="C、数组"></a>C、数组</h2><h2 id="D、List"><a href="#D、List" class="headerlink" title="D、List"></a>D、List</h2><h2 id="E、set"><a href="#E、set" class="headerlink" title="E、set"></a>E、set</h2><h2 id="F、Map"><a href="#F、Map" class="headerlink" title="F、Map"></a>F、Map</h2> <bean id="us" class="com.bjsxt.spring4.User">
        <property name="arr">
            <array>
                 <value>A</value>
                 <value>B</value>
                 <value>C</value>
            </array>
        </property>
        <property name="li">
            <list>
                <value>A</value>
                <value>B</value>
                <value>C</value>
            </list>
        </property>
        <property name="se">
            <set>
                <value>A</value>
                <value>A</value>
                <value>B</value>
                <value>C</value>
            </set>
        </property>
        <property name="map">

<pre><code>&lt;map&gt;
    &lt;entry&gt;
        &lt;key&gt;&lt;value&gt;A&lt;/value&gt;&lt;/key&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
        &lt;key&gt;&lt;value&gt;B&lt;/value&gt;&lt;/key&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/entry&gt;
    &lt;entry&gt;
        &lt;key&gt;&lt;value&gt;C&lt;/value&gt;&lt;/key&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/entry&gt;
&lt;/map&gt;</code></pre><p>​        </p></property><br>​    </bean><p></p>
<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="1-为什么学习SpringAop"><a href="#1-为什么学习SpringAop" class="headerlink" title="[1]为什么学习SpringAop?"></a>[1]为什么学习SpringAop?</h2><pre><code>IOC:帮助我们创建对象的

Aop:提升代码的扩展性</code></pre><h2 id="2-Aop的概念"><a href="#2-Aop的概念" class="headerlink" title="[2]Aop的概念"></a>[2]Aop的概念</h2><p>   Aop：Aspect Oriented Programming</p>
<p>   中文含义：面向切面编程</p>
<p>通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术</p>
<p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</p>
<h2 id="3-Aop中需要知道的要素"><a href="#3-Aop中需要知道的要素" class="headerlink" title="[3]Aop中需要知道的要素"></a>[3]Aop中需要知道的要素</h2><p>   切点：在执行的每一个方法都可以看作是一个切点</p>
<p>   通知：就是我们需要扩展的功能代码</p>
<pre><code>在切点之前增加的通知称之为前置通知

在切点之后增加的通知称之为后置通知

在切点之前和切点之后都增加的通知称之为环绕通知

在切点代码中有异常会执行的通知称之为异常通知</code></pre><p>   切面：有了切点+通知就可以织成切面</p>
<h2 id="4-Aop实现的方式"><a href="#4-Aop实现的方式" class="headerlink" title="[4]Aop实现的方式"></a>[4]Aop实现的方式</h2><p>   A、Schema base</p>
<p>   B、AspectJ</p>
<h2 id="5-理解示意图"><a href="#5-理解示意图" class="headerlink" title="[5]理解示意图"></a>[5]理解示意图</h2><p><img src="D:%5Cgit%5Cblogs%5Csource_posts%5Cimages%5C9.png" alt></p>
<h1 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h1><h2 id="1-我们目前使用AOP的不足？"><a href="#1-我们目前使用AOP的不足？" class="headerlink" title="[1]我们目前使用AOP的不足？"></a>[1]我们目前使用AOP的不足？</h2><pre><code>我们目前使用的schema Baes 实现的方式，发现了每一个通知都需要实现对应的接口，每一个接口中就是一个方法，这样的书写方式比较的麻烦的，我们想所有的方法都在一个类中书写就比较方便了。</code></pre><h2 id="2-解决方式"><a href="#2-解决方式" class="headerlink" title="[2]解决方式"></a>[2]解决方式</h2><p>   Aspect J方式实现</p>
<p>   我们发现 Aspect J的方式虽然可以把所有的通知都结合到一起，书写方便，但是获得切点中的参数和切点所在的类的时候比较的繁琐</p>
<p>[3]两种方式的使用场景</p>
<p>   A、schema base  ：如果我们需要使用切点中的参数或者切点所在的类对象的时候</p>
<p>   B、aspect J:就是简单的给切点增加通知的时候使用这个方式比较简单</p>
<p>通知代码</p>
<p>public class AspectJAdvice {<br>    //前置通知方法<br>    public   void   beforAd(JoinPoint joinPoint){<br>        System.out.println(“前置通知”);<br>    }<br>    //后置通知方法<br>    public   void   afterAd(){<br>        System.out.println(“后置通知”);<br>    }<br>    //环绕通知方法<br>    public   Object   aroundAd(ProceedingJoinPoint point) throws Throwable{<br>        System.out.println(“环绕通知–前”);<br>        Object o = point.proceed();<br>        System.out.println(“环绕通知–后”);<br>        return o;<br>    }<br>    //异常通知方法<br>    public   void   throwsAd(){<br>        System.out.println(“异常通知”);<br>    }<br>}
配置代码</p>
<p><bean id="us" class="com.bjsxt.pojo.User"></bean><br>      <!--配置通知类的对象--><br>      <bean id="aps" class="com.bjsxt.advice.AspectJAdvice"></bean><br>     <a href="aop:config" target="_blank" rel="noopener">aop:config</a><br>         &lt;aop:aspect ref=”aps”&gt;<br>             &lt;aop:pointcut id=”pt” expression=”execution(* com.bjsxt.pojo.User.a())”&gt;<br>             <!--给切点增加对应的通知--><br>             &lt;aop:before method=”beforAd” pointcut-ref=”pt”&gt;<br>             <!--无论切点中方法是否有异常，这个后置通知都会执行--><br>             &lt;aop:after method=”afterAd” pointcut-ref=”pt”&gt;<br>             <!--只有切点中的方法没有异常的时候才会执行这个通知--><br>             &lt;!–&lt;aop:after-returning method=”afterAd” pointcut-ref=”pt”&gt;<br>             &lt;aop:around method=”aroundAd” pointcut-ref=”pt”&gt;<br>             &lt;aop:after-throwing method=”throwsAd” pointcut-ref=”pt”&gt;<br>         <br>     </p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="Spring-中的内容"><a href="#Spring-中的内容" class="headerlink" title="Spring 中的内容"></a>Spring 中的内容</h2><p>  IOC：控制反转–帮助我们创建对象的也是解耦</p>
<p>  AOP：面向切面–提升代码的扩展性和解耦</p>
<p>  TX：声明式事务</p>
<h2 id="事务有四个特性（ACID）"><a href="#事务有四个特性（ACID）" class="headerlink" title="事务有四个特性（ACID）"></a>事务有四个特性（ACID）</h2><p>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</p>
<p>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</p>
<p>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</p>
<p>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中</p>
<h2 id="1-为什么使用事务"><a href="#1-为什么使用事务" class="headerlink" title="[1]为什么使用事务"></a>[1]为什么使用事务</h2><p>   我们当时学习mybatis的时候知道，mybatis中的事务和JDBC事务是一致的，那么Spring中式如何进行事务管理的呢？</p>
<h2 id="2-事务管理"><a href="#2-事务管理" class="headerlink" title="[2]事务管理"></a>[2]事务管理</h2><pre><code>编程式事务：整个事务管理都是需要程序员自己手动编写，自己提交或者回滚</code></pre><p>  事务管理<br>            声明式事务：就是整个事务的管理操作，不需要我们自己书写，现在Spring已经帮你处理好了，我们自己只要代码中声明配置即可。</p>
<h2 id="3-事务使用的场景"><a href="#3-事务使用的场景" class="headerlink" title="[3]事务使用的场景"></a>[3]事务使用的场景</h2><p>   当我们执行的式两条或者两条以上的添加、修改、删除的时候才使用事务</p>
<h2 id="4-使用Spring-中声明式事务"><a href="#4-使用Spring-中声明式事务" class="headerlink" title="[4]使用Spring 中声明式事务"></a>[4]使用Spring 中声明式事务</h2><pre><code>给方法增加事务 就是给切点增加通知


切点：需要的方法

通知：事务

构成切面</code></pre><p>[5]使用的时候需要注意</p>
<pre><code>我们增加事务的代码块不可以自己捕获异常，如果自己进行了异常的捕获，spring就没有办法得知此事的异常，这个时候我们配置的声明式事务就不再起作用
 如果我们就需要书写try  catch 还要结合声明式事务，这个时候就需要自己手动抛异常</code></pre><p>[6]代码实现</p>
<!--声明事务的对象-->
<pre><code>&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;tx:advice id=&quot;ad&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;login&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
&lt;!--通过配置切面的方式增加通知--&gt;

&lt;aop:config&gt;

    &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.bjsxt.service.impl.AdminServiceImpl.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:advisor advice-ref=&quot;ad&quot; pointcut-ref=&quot;pt&quot;&gt;&lt;/aop:advisor&gt;

&lt;/aop:config&gt;</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/30/spring回顾/" data-id="ck47s7r5e0006r4r8md2ft5i9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/30/springmvc回顾/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          springmvc回顾
        
      </div>
    </a>
  
  
    <a href="/2019/08/30/springdData注解/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">springdData注解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/lombok注解/">lombok注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目解读/">项目解读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/lombok注解/" style="font-size: 10px;">lombok注解</a> <a href="/tags/项目解读/" style="font-size: 10px;">项目解读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/06/activiti总结/">activiti总结</a>
          </li>
        
          <li>
            <a href="/2019/11/19/hn注解/">hn注解</a>
          </li>
        
          <li>
            <a href="/2019/09/30/springmvc回顾/">springmvc回顾</a>
          </li>
        
          <li>
            <a href="/2019/09/30/spring回顾/">spring回顾</a>
          </li>
        
          <li>
            <a href="/2019/08/30/springdData注解/">springdData注解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>